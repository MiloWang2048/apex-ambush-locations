# TS-RPC

## TL;DR

TS-RPC 是一款为全栈开发者的准备的后端框架，基于 Express 和 Typescript。

使用 TS-RPC 进行开发时，调用后端服务就像调用普通的异步函数一样，并且类型声明完全由后端动态生成，最大程度的减少了工作量。

## What is TS-RPC?

一个基于 express 的简易后端框架，主要功能有

- 将一组异步函数转换为 http 端点
- 基于文件系统的简单路由（与 nestjs 的路由机制类似）
- 直接生成可被前端引用的请求 client
- 完全的 Ts 和 monorepo 支持
- 一个简单的 cli，提供包括监听构建之类的有用工具

## Why TS-RPC?

想象这样一个场景：你要单独开发一个 web 项目，前端和后端都得自己写。如果采用标准的前后端分离开发模式，在整个过程中，处理前后端交互会占用大部分时间。如果你使用 ts，还得为每个请求编写请求和响应类型。

当后端接口结构因为不可抗力发生改变时，你需要耗费大量时间来处理一致性问题，如果你不小心弄错了某个接口的结构，造成的错误可能又得消耗大量进行 debug 和修复。显然，这种手动处理前后端交互的方式非常低效。

在理想情况下，TS-RPC 将能够达到这样的效果：

- 开发者完全不与 http 打交道，调用后端服务就像直接调用某个 npm 包那样简单
- 开发者完全不用编写任何前端请求模块，直接由后端代码生成
- 完全的 Typescript 支持，如果有请求结构上的错误能够在编译阶段被检查出来

这就是编写这个小框架的原因。它从原理到设计上都很简单，能够极大程度提升开发效率。

## Getting started

要创建一个使用 TS-RPC 的 web 项目，最快的方式是直接克隆模板仓库：

首先你需要对[Monorepo](https://monorepo.tools/)和[Yarn workspace](https://classic.yarnpkg.com/lang/en/docs/workspaces/)有基本的了解。

> 这是因为要从前端项目引用后端项目中的文件，将两个项目（或者说两个 npm 包）放在一个仓库中是比较明智的选择，这可以避免前后端版本不一致造成的困扰。

## TODO

- [ ] 自定义全局错误处理器
- [ ] 自定义 logger
- [ ] 错误类型拦截器
- [ ] 优化类型导出方案
- [ ] client 直接生成到前端目录，由前端构建系统编译
- [ ] 测试手段
- [ ] tsc构建缓存
- [ ] HMR
